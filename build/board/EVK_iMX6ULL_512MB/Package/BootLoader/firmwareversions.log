U-Boot commit information:
https://github.com/ms-iot/SolidRun-u-boot.git
1be4d10cde02b6e734dfa4d1379288244cbdb30d
U-Boot diff information:
diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index cf0dbf9..e24df7e 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -75,6 +75,7 @@ config MX6UL_OPOS6UL
 	select SUPPORT_SPL
 
 config MX6ULL
+	select HAS_CAAM
 	select SYS_L2CACHE_OFF
 	select ROM_UNIFIED_SECTIONS
 	select SYSCOUNTER_TIMER
@@ -344,6 +345,24 @@ config TARGET_MX6ULL_14X14_EVK
 	select MX6ULL
 	select DM
 	select DM_THERMAL
+	
+config TARGET_MYS_IMX6ULL_14X14
+	bool "Support MYiR mys-imx6ull"
+	select BOARD_LATE_INIT
+	select MX6ULL
+	select DM
+	select DM_THERMAL
+	select SUPPORT_SPL
+	select BOARD_EARLY_INIT_F
+	
+config TARGET_MX6ULL_EVK_BOARD
+	bool "Support mx6ull_evk_board"
+	select BOARD_LATE_INIT
+	select MX6ULL
+	select DM
+	select DM_THERMAL
+	select SUPPORT_SPL
+	select BOARD_EARLY_INIT_F
 
 config TARGET_NITROGEN6X
 	bool "nitrogen6x"
@@ -512,6 +531,8 @@ source "board/freescale/mx6sxsabresd/Kconfig"
 source "board/freescale/mx6sxsabreauto/Kconfig"
 source "board/freescale/mx6ul_14x14_evk/Kconfig"
 source "board/freescale/mx6ullevk/Kconfig"
+source "board/freescale/mx6ull_evk_board/Kconfig"
+source "board/freescale/mys_imx6ull/Kconfig"
 source "board/grinn/liteboard/Kconfig"
 source "board/phytec/pcm058/Kconfig"
 source "board/phytec/pfla02/Kconfig"
diff --git a/arch/arm/mach-imx/mx6/soc.c b/arch/arm/mach-imx/mx6/soc.c
index 9b3d8f6..5ce7e38 100644
--- a/arch/arm/mach-imx/mx6/soc.c
+++ b/arch/arm/mach-imx/mx6/soc.c
@@ -430,6 +430,14 @@ int arch_cpu_init(void)
 		 */
 		writel(readl(MX6UL_SNVS_LP_BASE_ADDR) |
 			0x3, MX6UL_SNVS_LP_BASE_ADDR);
+		udelay(20);
+		/* By pass ARP PLL first */
+		writel(readl(0x20C8000)| 0x10000, 0x20C8000);
+		/* Set clock divider and wait clock stable */
+ 		writel((readl(0x20C8000) & 0xFFFFFF80) | 0x10058, 0x20C8000);
+        udelay(200);
+		/* Switch to new clock */
+		writel(readl(0x20C8000) & 0xFFFEFFFF, 0x20C8000);
 	}
 
 	/* Set perclk to source from OSC 24MHz */
diff --git a/common/console.c b/common/console.c
index 0e02955..773b04a 100644
--- a/common/console.c
+++ b/common/console.c
@@ -294,14 +294,21 @@ int serial_printf(const char *fmt, ...)
 {
 	va_list args;
 	uint i;
-	char printbuffer[CONFIG_SYS_PBSIZE];
+	char printbuffer[CONFIG_SYS_PBSIZE] = {0};
 
 	va_start(args, fmt);
 
 	/* For this to work, printbuffer must be larger than
 	 * anything we ever want to print.
 	 */
+	#ifndef SPL_BUILD
 	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
+	#else
+	i = sprintf(printbuffer, fmt, args);
+	va_end(args);
+	puts(printbuffer);
+	return i;
+	#endif
 	va_end(args);
 
 	serial_puts(printbuffer);
diff --git a/common/spl/spl.c b/common/spl/spl.c
index 9c1c1c0..f0343da 100644
--- a/common/spl/spl.c
+++ b/common/spl/spl.c
@@ -316,7 +316,11 @@ int spl_init(void)
 
 __weak void board_boot_order(u32 *spl_boot_list)
 {
+	char s[64] = {0};
 	spl_boot_list[0] = spl_boot_device();
+	sprintf(s, "Boot device %d\n", spl_boot_list[0]);
+	puts(s);
+	printf("spl: Boot device %d\n", spl_boot_list[0]);
 }
 
 static struct spl_image_loader *spl_ll_find_loader(uint boot_device)
diff --git a/common/spl/spl_mmc.c b/common/spl/spl_mmc.c
index db5be3d..d6635d7 100644
--- a/common/spl/spl_mmc.c
+++ b/common/spl/spl_mmc.c
@@ -62,11 +62,15 @@ int mmc_load_image_raw_sector(struct spl_image_info *spl_image,
 
 	/* read image header to find the image size & load address */
 	count = blk_dread(mmc_get_blk_desc(mmc), sector, 1, header);
-	debug("hdr read sector %lx, count=%lu\n", sector, count);
+	debug("spl: %s hdr read sector %lx, count=%lu \n", __func__, sector, count);
 	if (count == 0) {
 		ret = -EIO;
+		debug("spl: %s ret %d\n", __func__, ret);
 		goto end;
 	}
+	debug("spl: %s to load FIT s\n", __func__);
+	debug("spl: %s text base %lx\n", __func__, CONFIG_SYS_TEXT_BASE);
+	debug("spl: %s text base %lx, header address %lx s\n", __func__, CONFIG_SYS_TEXT_BASE, header);
 
 	if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 	    image_get_magic(header) == FDT_MAGIC) {
@@ -80,7 +84,9 @@ int mmc_load_image_raw_sector(struct spl_image_info *spl_image,
 		load.read = h_spl_load_read;
 		ret = spl_load_simple_fit(spl_image, &load, sector, header);
 	} else {
+		debug("spl: %s to load legacy %x\n", __func__, header->ih_magic);
 		ret = mmc_load_legacy(spl_image, mmc, sector, header);
+		debug("spl: %s -> mmc_load_legacy %d\n", __func__, ret);
 	}
 
 end:
@@ -119,10 +125,12 @@ static int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device)
 	int err, mmc_dev;
 
 	mmc_dev = spl_mmc_get_device_index(boot_device);
+	debug("spl: %s -> spl_mmc_get_device_index mmc_dev %d \n", __func__, mmc_dev);
 	if (mmc_dev < 0)
 		return mmc_dev;
 
 	err = mmc_initialize(NULL);
+	debug("spl: %s -> mmc_initialize %d \n", __func__, err);
 	if (err) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
 		printf("spl: could not initialize mmc. error: %d\n", err);
@@ -132,11 +140,13 @@ static int spl_mmc_find_device(struct mmc **mmcp, u32 boot_device)
 
 #if CONFIG_IS_ENABLED(DM_MMC)
 	err = uclass_get_device(UCLASS_MMC, mmc_dev, &dev);
+	serial_printf("spl: uclass_get_device with error: %d\n", err);
 	if (!err)
 		*mmcp = mmc_get_mmc_dev(dev);
 #else
 	*mmcp = find_mmc_device(mmc_dev);
 	err = *mmcp ? 0 : -ENODEV;
+	serial_printf("spl: find_mmc_device with error: %d\n", err);
 #endif
 	if (err) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
@@ -171,6 +181,7 @@ static int mmc_load_image_raw_partition(struct spl_image_info *spl_image,
 #endif
 
 	err = part_get_info(mmc_get_blk_desc(mmc), partition, &info);
+	debug("spl: %s -> part_get_info err %d \n", __func__, err);
 	if (err) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
 		puts("spl: partition error\n");
@@ -306,10 +317,12 @@ int spl_mmc_load_image(struct spl_image_info *spl_image,
 	__maybe_unused int part;
 
 	err = spl_mmc_find_device(&mmc, bootdev->boot_device);
+	debug("spl: %s -> spl_mmc_find_device %d \n", __func__, err);
 	if (err)
 		return err;
 
 	err = mmc_init(mmc);
+	debug("spl: %s -> mmc_init %d \n", __func__, err);
 	if (err) {
 #ifdef CONFIG_SPL_LIBCOMMON_SUPPORT
 		printf("spl: mmc init failed with error: %d\n", err);
@@ -318,6 +331,7 @@ int spl_mmc_load_image(struct spl_image_info *spl_image,
 	}
 
 	boot_mode = spl_boot_mode(bootdev->boot_device);
+	debug("spl: %s -> spl_boot_mode mode %d \n", __func__, boot_mode);
 	err = -EINVAL;
 	switch (boot_mode) {
 	case MMCSD_MODE_EMMCBOOT:
@@ -348,21 +362,28 @@ int spl_mmc_load_image(struct spl_image_info *spl_image,
 
 		if (!spl_start_uboot()) {
 			err = mmc_load_image_raw_os(spl_image, mmc);
+			debug("spl: %s -> mmc_load_image_raw_os %d \n", __func__, err);
 			if (!err)
 				return err;
 		}
+		debug("spl: mmc to load partition\n");
 #ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION
+		debug("spl: CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_PARTITION \n");
 		err = spl_boot_partition(bootdev->boot_device);
+		debug("spl: %s -> spl_boot_partition err %d \n", __func__, err);
 		if (!err)
 			return err;
 
 		err = mmc_load_image_raw_partition(spl_image, mmc, err);
+		debug("spl: %s -> spl_boot_partition err %d \n", __func__, err);
 		if (!err)
 			return err;
 #endif
 #ifdef CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR
+		debug("spl: %s to load image \n", __func__);
 		err = mmc_load_image_raw_sector(spl_image, mmc,
 			CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR);
+		debug("spl: %s -> mmc_load_image_raw_sector err %d \n", __func__, err);
 		if (!err)
 			return err;
 #endif
@@ -381,6 +402,7 @@ int spl_mmc_load_image(struct spl_image_info *spl_image,
 #endif
 	}
 
+	debug("spl: %s err %d \n", __func__, err);
 	return err;
 }
 
diff --git a/drivers/block/blk-uclass.c b/drivers/block/blk-uclass.c
index c32aee6..267c076 100644
--- a/drivers/block/blk-uclass.c
+++ b/drivers/block/blk-uclass.c
@@ -380,8 +380,8 @@ int blk_find_device(int if_type, int devnum, struct udevice **devp)
 	uclass_foreach_dev(dev, uc) {
 		struct blk_desc *desc = dev_get_uclass_platdata(dev);
 
-		debug("%s: if_type=%d, devnum=%d: %s, %d, %d\n", __func__,
-		      if_type, devnum, dev->name, desc->if_type, desc->devnum);
+		/* debug("%s: if_type=%d, devnum=%d: %s, %d, %d\n", __func__,
+		      if_type, devnum, dev->name, desc->if_type, desc->devnum); */
 		if (desc->if_type == if_type && desc->devnum == devnum) {
 			*devp = dev;
 			return 0;
diff --git a/drivers/mmc/mmc.c b/drivers/mmc/mmc.c
index c930893..e4aac83 100644
--- a/drivers/mmc/mmc.c
+++ b/drivers/mmc/mmc.c
@@ -1481,12 +1481,14 @@ static int mmc_execute_tuning(struct mmc *mmc, uint opcode)
 
 static void mmc_send_init_stream(struct mmc *mmc)
 {
+	debug("spl: %s in \n", __func__);
 }
 
 static int mmc_set_ios(struct mmc *mmc)
 {
 	int ret = 0;
 
+	debug("spl: %s in \n", __func__);
 	if (mmc->cfg->ops->set_ios)
 		ret = mmc->cfg->ops->set_ios(mmc);
 
@@ -1496,6 +1498,7 @@ static int mmc_set_ios(struct mmc *mmc)
 
 int mmc_set_clock(struct mmc *mmc, uint clock, bool disable)
 {
+	debug("spl: %s in \n", __func__);
 	if (!disable) {
 		if (clock > mmc->cfg->f_max)
 			clock = mmc->cfg->f_max;
@@ -1512,6 +1515,7 @@ int mmc_set_clock(struct mmc *mmc, uint clock, bool disable)
 
 static int mmc_set_bus_width(struct mmc *mmc, uint width)
 {
+	debug("spl: %s in \n", __func__);
 	mmc->bus_width = width;
 
 	return mmc_set_ios(mmc);
@@ -1526,6 +1530,7 @@ static int mmc_set_bus_width(struct mmc *mmc, uint width)
 void mmc_dump_capabilities(const char *text, uint caps)
 {
 	enum bus_mode mode;
+	debug("spl: %s in \n", __func__);
 
 	pr_debug("%s: widths [", text);
 	if (caps & MMC_MODE_8BIT)
@@ -1565,6 +1570,7 @@ int mmc_voltage_to_mv(enum mmc_voltage voltage)
 static int mmc_set_signal_voltage(struct mmc *mmc, uint signal_voltage)
 {
 	int err;
+	debug("spl: %s in \n", __func__);
 
 	if (mmc->signal_voltage == signal_voltage)
 		return 0;
@@ -2389,6 +2395,7 @@ static int mmc_power_init(struct mmc *mmc)
 #if CONFIG_IS_ENABLED(DM_REGULATOR)
 	int ret;
 
+	debug("spl: %s in \n", __func__);
 	ret = device_get_supply_regulator(mmc->dev, "vmmc-supply",
 					  &mmc->vmmc_supply);
 	if (ret)
@@ -2404,6 +2411,7 @@ static int mmc_power_init(struct mmc *mmc)
 	 * Driver model should use a regulator, as above, rather than calling
 	 * out to board code.
 	 */
+	debug("spl: %s in \n", __func__);
 	board_mmc_power_init();
 #endif
 	return 0;
@@ -2419,6 +2427,7 @@ static void mmc_set_initial_state(struct mmc *mmc)
 	int err;
 
 	/* First try to set 3.3V. If it fails set to 1.8V */
+	debug("spl: %s in \n", __func__);
 	err = mmc_set_signal_voltage(mmc, MMC_SIGNAL_VOLTAGE_330);
 	if (err != 0)
 		err = mmc_set_signal_voltage(mmc, MMC_SIGNAL_VOLTAGE_180);
@@ -2432,6 +2441,7 @@ static void mmc_set_initial_state(struct mmc *mmc)
 
 static int mmc_power_on(struct mmc *mmc)
 {
+	debug("spl: %s in \n", __func__);
 #if CONFIG_IS_ENABLED(DM_MMC) && CONFIG_IS_ENABLED(DM_REGULATOR)
 	if (mmc->vmmc_supply) {
 		int ret = regulator_set_enable(mmc->vmmc_supply, true);
@@ -2447,6 +2457,7 @@ static int mmc_power_on(struct mmc *mmc)
 
 static int mmc_power_off(struct mmc *mmc)
 {
+	debug("spl: %s in \n", __func__);
 	mmc_set_clock(mmc, 0, true);
 #if CONFIG_IS_ENABLED(DM_MMC) && CONFIG_IS_ENABLED(DM_REGULATOR)
 	if (mmc->vmmc_supply) {
@@ -2465,6 +2476,7 @@ static int mmc_power_cycle(struct mmc *mmc)
 {
 	int ret;
 
+	debug("spl: %s in \n", __func__);
 	ret = mmc_power_off(mmc);
 	if (ret)
 		return ret;
@@ -2486,6 +2498,7 @@ int mmc_start_init(struct mmc *mmc)
 	 * all hosts are capable of 1 bit bus-width and able to use the legacy
 	 * timings.
 	 */
+	debug("spl: %s in \n", __func__);
 	mmc->host_caps = mmc->cfg->host_caps | MMC_CAP(SD_LEGACY) |
 			 MMC_CAP(MMC_LEGACY) | MMC_MODE_1BIT;
 
@@ -2614,18 +2627,26 @@ int mmc_init(struct mmc *mmc)
 
 	upriv->mmc = mmc;
 #endif
+	debug("spl: %s in \n", __func__);
 	if (mmc->has_init)
 		return 0;
 
 	start = get_timer(0);
 
 	if (!mmc->init_in_progress)
+	{
 		err = mmc_start_init(mmc);
+		debug("spl: %s -> mmc_start_init %d \n", __func__, err);
+	}
 
 	if (!err)
+	{
 		err = mmc_complete_init(mmc);
+		debug("spl: %s -> mmc_start_init %d \n", __func__, err);
+	}
 	if (err)
 		pr_info("%s: %d, time %lu\n", __func__, err, get_timer(start));
+	debug("spl: %s out err %d \n", __func__, err);
 
 	return err;
 }
@@ -2661,6 +2682,7 @@ static int mmc_probe(bd_t *bis)
 	struct udevice *dev;
 
 	ret = uclass_get(UCLASS_MMC, &uc);
+	serial_printf("spl: uclass_get(UCLASS_MMC): %d\n", ret);
 	if (ret)
 		return ret;
 
@@ -2671,13 +2693,17 @@ static int mmc_probe(bd_t *bis)
 	 */
 	for (i = 0; ; i++) {
 		ret = uclass_get_device_by_seq(UCLASS_MMC, i, &dev);
+		serial_printf("spl: uclass_get_device_by_seq(%d, %x): %d\n", i, dev, ret);
 		if (ret == -ENODEV)
 			break;
 	}
 	uclass_foreach_dev(dev, uc) {
 		ret = device_probe(dev);
 		if (ret)
+		{
 			pr_err("%s - probe failed: %d\n", dev->name, ret);
+			serial_printf("spl: device_probe(%x): %d\n", dev, ret);
+		}
 	}
 
 	return 0;
@@ -2709,9 +2735,9 @@ int mmc_initialize(bd_t *bis)
 	if (ret)
 		return ret;
 
-#ifndef CONFIG_SPL_BUILD
+//#ifndef CONFIG_SPL_BUILD
 	print_mmc_devices(',');
-#endif
+//#endif
 
 	mmc_do_preinit();
 	return 0;
diff --git a/fs/fat/fat.c b/fs/fat/fat.c
index dd7888c..b19c542 100644
--- a/fs/fat/fat.c
+++ b/fs/fat/fat.c
@@ -189,8 +189,8 @@ static __u32 get_fatent(fsdata *mydata, __u32 entry)
 		return ret;
 	}
 
-	debug("FAT%d: entry: 0x%08x = %d, offset: 0x%04x = %d\n",
-	       mydata->fatsize, entry, entry, offset, offset);
+	/* debug("FAT%d: entry: 0x%08x = %d, offset: 0x%04x = %d\n",
+	       mydata->fatsize, entry, entry, offset, offset); */
 
 	/* Read a new block of FAT entries into the cache. */
 	if (bufnum != mydata->fatbufnum) {
@@ -233,8 +233,8 @@ static __u32 get_fatent(fsdata *mydata, __u32 entry)
 			ret >>= 4;
 		ret &= 0xfff;
 	}
-	debug("FAT%d: ret: 0x%08x, entry: 0x%08x, offset: 0x%04x\n",
-	       mydata->fatsize, ret, entry, offset);
+	/* debug("FAT%d: ret: 0x%08x, entry: 0x%08x, offset: 0x%04x\n",
+	       mydata->fatsize, ret, entry, offset); */
 
 	return ret;
 }
U-Boot diff end
OPTEE commit information:
https://github.com/ms-iot/optee_os.git
ab616627d2ef6c2dc9a1be4eb05a3bd35edb5e2c
OPTEE diff information:
diff --git a/lib/libutils/ext/include/trace.h b/lib/libutils/ext/include/trace.h
index 7bb82c4..ccd5f63 100644
--- a/lib/libutils/ext/include/trace.h
+++ b/lib/libutils/ext/include/trace.h
@@ -17,6 +17,12 @@
 #define TRACE_LEVEL TRACE_MAX
 #endif
 
+#ifdef TRACE_LEVEL
+#undef TRACE_LEVEL
+#define TRACE_LEVEL TRACE_MAX
+#endif
+
+
 /*
  * Symbols provided by the entity that uses this API.
  */
@@ -60,14 +66,14 @@ void trace_printf(const char *func, int line, int level, bool level_ok,
 #if (TRACE_LEVEL < TRACE_DEBUG)
 #define DMSG(...)   (void)0
 #else
-#define DMSG(...)   trace_printf_helper(TRACE_DEBUG, true, __VA_ARGS__)
+#define DMSG(...)   trace_printf_helper(TRACE_INFO, true, __VA_ARGS__)
 #endif
 
 /* Formatted trace tagged with TRACE_FLOW level */
 #if (TRACE_LEVEL < TRACE_FLOW)
 #define FMSG(...)   (void)0
 #else
-#define FMSG(...)   trace_printf_helper(TRACE_FLOW, true, __VA_ARGS__)
+#define FMSG(...)   trace_printf_helper(TRACE_INFO, true, __VA_ARGS__)
 #endif
 
 /* Formatted trace tagged with TRACE_FLOW level and prefix with '> ' */
OPTEE diff end
EDK2 commit information:
https://github.com/tianocore/edk2
da2c81ee96eba5d5c8ef91fd870ac98d3cf72beb
EDK2 diff information:
diff --git a/ArmPkg/Library/PlatformBootManagerLib/PlatformBm.c b/ArmPkg/Library/PlatformBootManagerLib/PlatformBm.c
index 81d36f2..08f3ae7 100644
--- a/ArmPkg/Library/PlatformBootManagerLib/PlatformBm.c
+++ b/ArmPkg/Library/PlatformBootManagerLib/PlatformBm.c
@@ -96,7 +96,6 @@ STATIC PLATFORM_SERIAL_CONSOLE mSerialConsole = {
   }
 };
 
-
 #pragma pack (1)
 typedef struct {
   USB_CLASS_DEVICE_PATH    Keyboard;
@@ -129,7 +128,6 @@ STATIC PLATFORM_USB_KEYBOARD mUsbKeyboard = {
   }
 };
 
-
 /**
   Check if the handle satisfies a particular condition.
 
@@ -584,7 +582,6 @@ PlatformBootManagerBeforeConsole (
   //
   EfiBootManagerUpdateConsoleVariable (ConIn,
     (EFI_DEVICE_PATH_PROTOCOL *)&mUsbKeyboard, NULL);
-
   //
   // Add the hardcoded serial console device path to ConIn, ConOut, ErrOut.
   //
@@ -684,6 +681,8 @@ PlatformBootManagerAfterConsole (
   //
   // Show the splash screen.
   //
+  DEBUG ((EFI_D_VERBOSE, "[Bds] PlatformBootManagerAfterConsole: BootLogoEnableLogo\n"));
+
   Status = BootLogoEnableLogo ();
   if (EFI_ERROR (Status)) {
     if (FirmwareVerLength > 0) {
@@ -708,6 +707,7 @@ PlatformBootManagerAfterConsole (
   //
   // Connect the rest of the devices.
   //
+  DEBUG ((EFI_D_VERBOSE, "[Bds] PlatformBootManagerAfterConsole: EfiBootManagerConnectAll\n"));
   EfiBootManagerConnectAll ();
 
   //
diff --git a/MdeModulePkg/Core/Dxe/DxeMain/DxeProtocolNotify.c b/MdeModulePkg/Core/Dxe/DxeMain/DxeProtocolNotify.c
index ac9edf7..dd048da 100644
--- a/MdeModulePkg/Core/Dxe/DxeMain/DxeProtocolNotify.c
+++ b/MdeModulePkg/Core/Dxe/DxeMain/DxeProtocolNotify.c
@@ -91,6 +91,10 @@ CoreAllEfiServicesAvailable (
 
   for (Entry = mArchProtocols; Entry->ProtocolGuid != NULL; Entry++) {
     if (!Entry->Present) {
+		DEBUG ((
+            DEBUG_INFO | DEBUG_LOAD,
+            "    gdsfdg         %g \n",Entry->ProtocolGuid
+            ));
       return EFI_NOT_FOUND;
     }
   }
diff --git a/MdeModulePkg/Core/Dxe/Event/Event.c b/MdeModulePkg/Core/Dxe/Event/Event.c
index 86ca369..6f3a284 100644
--- a/MdeModulePkg/Core/Dxe/Event/Event.c
+++ b/MdeModulePkg/Core/Dxe/Event/Event.c
@@ -93,6 +93,8 @@ UINT32 mEventTable[] = {
 ///
 EFI_EVENT       gIdleLoopEvent = NULL;
 
+UINT32 logmask = 0;
+
 
 /**
   Enter critical section by acquiring the lock on gEventQueueLock.
@@ -226,7 +228,9 @@ CoreNotifyEvent (
   //
   // Event database must be locked
   //
+  DEBUG ((logmask, "+NE\n"));
   ASSERT_LOCKED (&gEventQueueLock);
+  DEBUG ((logmask, "NE\n"));
 
   //
   // If the event is queued somewhere, remove it
@@ -234,6 +238,7 @@ CoreNotifyEvent (
 
   if (Event->NotifyLink.ForwardLink != NULL) {
     RemoveEntryList (&Event->NotifyLink);
+	DEBUG ((logmask, "NE RE\n"));
     Event->NotifyLink.ForwardLink = NULL;
   }
 
@@ -242,7 +247,9 @@ CoreNotifyEvent (
   //
 
   InsertTailList (&gEventQueue[Event->NotifyTpl], &Event->NotifyLink);
+  DEBUG ((logmask, "NE IL\n"));
   gEventPending |= (UINTN)(1 << Event->NotifyTpl);
+  DEBUG ((logmask, "-NE\n"));
 }
 
 
@@ -262,18 +269,23 @@ CoreNotifySignalList (
   LIST_ENTRY              *Link;
   LIST_ENTRY              *Head;
   IEVENT                  *Event;
-
+  DEBUG ((logmask, "+SL\n"));
   CoreAcquireEventLock ();
+  DEBUG ((logmask, "SL AL\n"));
 
   Head = &gEventSignalQueue;
   for (Link = Head->ForwardLink; Link != Head; Link = Link->ForwardLink) {
     Event = CR (Link, IEVENT, SignalLink, EVENT_SIGNATURE);
+	DEBUG ((logmask, "SL LE %x\n", Event));
     if (CompareGuid (&Event->EventGroup, EventGroup)) {
       CoreNotifyEvent (Event);
+	  DEBUG ((logmask, "SL NE %x\n", Event));
     }
   }
+  DEBUG ((logmask, "SL End\n"));
 
   CoreReleaseEventLock ();
+  DEBUG ((logmask, "-SL\n"));
 }
 
 
@@ -542,7 +554,10 @@ CoreSignalEvent (
     return EFI_INVALID_PARAMETER;
   }
 
+  DEBUG ((logmask, "+SE\n"));
+
   CoreAcquireEventLock ();
+  DEBUG ((logmask, "SE AL\n"));
 
   //
   // If the event is not already signalled, do so
@@ -561,15 +576,20 @@ CoreSignalEvent (
         //  to be signaled.
         //
         CoreReleaseEventLock ();
+		DEBUG ((logmask, "SE RL\n"));
         CoreNotifySignalList (&Event->EventGroup);
+		DEBUG ((logmask, "SE NL\n"));
         CoreAcquireEventLock ();
+		DEBUG ((logmask, "SE AL2\n"));
        } else {
         CoreNotifyEvent (Event);
+		DEBUG ((logmask, "SE NE\n"));
       }
     }
   }
 
   CoreReleaseEventLock ();
+  DEBUG ((logmask, "-SE\n"));
   return EFI_SUCCESS;
 }
 
@@ -686,7 +706,12 @@ CoreWaitForEvent (
 
     for(Index = 0; Index < NumberOfEvents; Index++) {
 
+	  //logmask = EFI_D_INFO;
+
+	  DEBUG ((logmask, "Wi%d\n", Index));
+
       Status = CoreCheckEvent (UserEvents[Index]);
+	  DEBUG ((logmask, "S%x\n", Status));
 
       //
       // provide index of event that caused problem
diff --git a/MdeModulePkg/Core/Dxe/Event/Tpl.c b/MdeModulePkg/Core/Dxe/Event/Tpl.c
index 28b9197..dd3508e 100644
--- a/MdeModulePkg/Core/Dxe/Event/Tpl.c
+++ b/MdeModulePkg/Core/Dxe/Event/Tpl.c
@@ -21,6 +21,8 @@ WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
   @param  Enable  The state of enable or disable interrupt
 
 **/
+	extern UINT32 logmask;
+
 VOID
 CoreSetInterruptState (
   IN BOOLEAN      Enable
@@ -28,12 +30,14 @@ CoreSetInterruptState (
 {
   EFI_STATUS  Status;
   BOOLEAN     InSmm;
-
+  DEBUG ((logmask, "CoreSetInterruptState %d\n", Enable));
   if (gCpu == NULL) {
     return;
   }
   if (!Enable) {
     gCpu->DisableInterrupt (gCpu);
+	
+	DEBUG ((logmask, "-CoreSetInterruptState dis\n"));
     return;
   }
   if (gSmmBase2 == NULL) {
@@ -44,6 +48,7 @@ CoreSetInterruptState (
   if (!EFI_ERROR (Status) && !InSmm) {
     gCpu->EnableInterrupt(gCpu);
   }
+  DEBUG ((logmask, "-CoreSetInterruptState %d\n", Enable));
 }
 
 
@@ -106,6 +111,8 @@ CoreRestoreTpl (
   EFI_TPL     PendingTpl;
 
   OldTpl = gEfiCurrentTpl;
+  
+  DEBUG ((logmask, "RestoreTpl with NewTpl(0x%x)  OldTpl(0x%x)\n", NewTpl, OldTpl));
   if (NewTpl > OldTpl) {
     DEBUG ((EFI_D_ERROR, "FATAL ERROR - RestoreTpl with NewTpl(0x%x) > OldTpl(0x%x)\n", NewTpl, OldTpl));
     ASSERT (FALSE);
@@ -151,4 +158,6 @@ CoreRestoreTpl (
     CoreSetInterruptState (TRUE);
   }
 
+  DEBUG ((logmask, "-RestoreTpl with NewTpl(0x%x)  OldTpl(0x%x)\n", NewTpl, OldTpl));
+
 }
diff --git a/MdeModulePkg/Universal/BdsDxe/BdsEntry.c b/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
index 8946d79..9811c78 100644
--- a/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
+++ b/MdeModulePkg/Universal/BdsDxe/BdsEntry.c
@@ -242,20 +242,26 @@ BdsWaitForSingleEvent (
       //
       // Set the timer event
       //
+      
+	  DEBUG ((EFI_D_INFO, "Before set timer\n"));
       gBS->SetTimer (
              TimerEvent,
              TimerRelative,
              Timeout
              );
+	  DEBUG ((EFI_D_INFO, "After set timer\n"));
 
       //
       // Wait for the original event or the timer
       //
       WaitList[0] = Event;
       WaitList[1] = TimerEvent;
+	  DEBUG ((EFI_D_INFO, "%x wait event %x, %x\n", gBS->WaitForEvent, Event, TimerEvent));
       Status      = gBS->WaitForEvent (2, WaitList, &Index);
+	  DEBUG ((EFI_D_INFO, "After wait event\n"));
       ASSERT_EFI_ERROR (Status);
       gBS->CloseEvent (TimerEvent);
+	  DEBUG ((EFI_D_INFO, "Close event\n"));
 
       //
       // If the timer expired, change the return to timed out
@@ -269,6 +275,7 @@ BdsWaitForSingleEvent (
     // No timeout... just wait on the event
     //
     Status = gBS->WaitForEvent (1, &Event, &Index);
+	DEBUG ((EFI_D_INFO, "WaitForEvent\n"));
     ASSERT (!EFI_ERROR (Status));
     ASSERT (Index == 0);
   }
@@ -326,23 +333,32 @@ BdsWait (
   while (TimeoutRemain != 0) {
     DEBUG ((EFI_D_INFO, "[Bds]BdsWait(%d)..Zzzz...\n", (UINTN) TimeoutRemain));
     PlatformBootManagerWaitCallback (TimeoutRemain);
-
+    DEBUG ((EFI_D_INFO, "[Bds1]BdsWait(%d)..Zzzz...\n", (UINTN) TimeoutRemain));
     BdsReadKeys (); // BUGBUG: Only reading can signal HotkeyTriggered
                     //         Can be removed after all keyboard drivers invoke callback in timer callback.
 
-    if (HotkeyTriggered != NULL) {
+    if (HotkeyTriggered != NULL) {	  
+	  DEBUG ((EFI_D_INFO, "[Bds2]BdsWait(%d)..Zzzz...\n", (UINTN) TimeoutRemain));
       Status = BdsWaitForSingleEvent (HotkeyTriggered, EFI_TIMER_PERIOD_SECONDS (1));
       if (!EFI_ERROR (Status)) {
         break;
       }
+	  
+	  DEBUG ((EFI_D_INFO, "[Bds2.1]BdsWait(%d)..Zzzz...\n", (UINTN) TimeoutRemain));
     } else {
+      
+	  DEBUG ((EFI_D_INFO, "[Bds3]BdsWait(%d)..Zzzz...\n", (UINTN) TimeoutRemain));
       gBS->Stall (1000000);
+	  
+	  DEBUG ((EFI_D_INFO, "[Bds3.1]BdsWait(%d)..Zzzz...\n", (UINTN) TimeoutRemain));
     }
 
     //
     // 0xffff means waiting forever
     // BDS with no hotkey provided and 0xffff as timeout will "hang" in the loop
     //
+    
+    DEBUG ((EFI_D_INFO, "[Bds4]BdsWait(%d)..Zzzz...\n", (UINTN) TimeoutRemain));
     if (TimeoutRemain != 0xffff) {
       TimeoutRemain--;
     }
EDK2 diff end
EDK2-Platforms commit information:
https://github.com/ms-iot/edk2-platforms.git
295b102d7685785e6ddb95fd3660b1c1271cc023
EDK2-Platforms diff information:
diff --git a/Silicon/NXP/iMX6Pkg/AcpiTables/Csrt.aslc b/Silicon/NXP/iMX6Pkg/AcpiTables/Csrt.aslc
index f838b82..b0efc16 100644
--- a/Silicon/NXP/iMX6Pkg/AcpiTables/Csrt.aslc
+++ b/Silicon/NXP/iMX6Pkg/AcpiTables/Csrt.aslc
@@ -37,7 +37,7 @@ typedef enum {
 #if defined(CPU_IMX6DQ) || defined (CPU_IMX6DQP)
   GPT_CLOCK_OSC_DIV_8   = 5,
   GPT_CLOCK_OSC         = 7,
-#elif (defined(CPU_IMX6SDL) || defined(CPU_IMX6SX))
+#elif (defined(CPU_IMX6SDL) || defined(CPU_IMX6SX)) || defined(CPU_IMX6ULL)
   GPT_CLOCK_OSC         = 5,
 #else
 #error iMX6 CPU Type Not Defined (Preprocessor Flag)
@@ -216,7 +216,7 @@ EFI_ACPI_CSRT_TABLE Csrt = {
         },
         TIMER_CAP_READABLE | TIMER_CAP_UP_COUNTER, // Capabilities
         32,                                 // Timer width (bits)
-        GPT_CLOCK_OSC,                      // Source is 111b for QD, 101b for SDL
+                GPT_CLOCK_OSC,                      // Source is 111b for QD, 101b for SDL/ULL
         SOC_OSC_FREQUENCY_REF_HZ,           // Frequency 24 MHz
         24,                                 // divider to make 1 MHz
         CSP_BASE_REG_PA_GPT,                // 32 bit Physical address
diff --git a/Silicon/NXP/iMX6Pkg/Application/ImxClkPwr/ImxClkPwr.c b/Silicon/NXP/iMX6Pkg/Application/ImxClkPwr/ImxClkPwr.c
index b0beabf..ee9b7be 100644
--- a/Silicon/NXP/iMX6Pkg/Application/ImxClkPwr/ImxClkPwr.c
+++ b/Silicon/NXP/iMX6Pkg/Application/ImxClkPwr/ImxClkPwr.c
@@ -58,6 +58,7 @@ typedef enum {
                               IMX_SION_DISABLED,
                               IMX_IOMUXC_GPIO1_IO11_ALT3_CCM_CLKO1)
 } IMX_CCM_PADCFG;
+#elif defined(CPU_IMX6ULL)
 #else
 #error iMX6ClkPwr - iMX6 CPU type not defined!
 #endif
@@ -105,6 +106,7 @@ EFI_STATUS PinOutClock (IMX_CLK Clock)
   ImxPadConfig(IMX_PAD_GPIO_0, IMX_PAD_CFG_GPIO_0_CCM_CLKO1);
 #elif defined(CPU_IMX6SX)
   ImxPadConfig (IMX_PAD_GPIO1_IO11, IMX_PAD_CFG_GPIO1_IO11_CCM_CLKO1);
+#elif defined(CPU_IMX6ULL)
 #else
 #error iMX6 CPU Type not defined
 #endif
diff --git a/Silicon/NXP/iMX6Pkg/Drivers/PlatformSmbiosDxe/PlatformSmbiosDxe.c b/Silicon/NXP/iMX6Pkg/Drivers/PlatformSmbiosDxe/PlatformSmbiosDxe.c
index 93c56de..601ce3d 100644
--- a/Silicon/NXP/iMX6Pkg/Drivers/PlatformSmbiosDxe/PlatformSmbiosDxe.c
+++ b/Silicon/NXP/iMX6Pkg/Drivers/PlatformSmbiosDxe/PlatformSmbiosDxe.c
@@ -1121,6 +1121,9 @@ ProcessorInfoUpdateSmbiosType4 (
 #elif defined(CPU_IMX6SDL) || defined(CPU_IMX6SX)
   mProcessorInfoType4.MaxSpeed = 1000;
   mProcessorInfoType4.CurrentSpeed = 1000;
+#elif defined(CPU_IMX6ULL)
+	mProcessorInfoType4.MaxSpeed = 528;
+	mProcessorInfoType4.CurrentSpeed = 528;
 #else
   #error iMX6 CPU Type not defined
 #endif
@@ -1378,6 +1381,9 @@ CacheInfoUpdateSmbiosType7L2U (
 #elif defined(CPU_IMX6SX)
   mCacheInfoType7L2U.MaximumCacheSize = 0x100; // 256KB
   mCacheInfoType7L2U.InstalledSize = 0x100; // 256KB
+#elif defined(CPU_IMX6ULL)
+  mCacheInfoType7L2U.MaximumCacheSize = 0x80; // 128KB
+  mCacheInfoType7L2U.InstalledSize = 0x80; // 128KB
 #else
   #error iMX6 CPU Type not defined
 #endif
@@ -1521,7 +1527,7 @@ MemoryDeviceInfoUpdateSmbiosType17 (
 #if defined(CPU_IMX6DQ) || defined(CPU_IMX6DQP) || defined(SOCTYPE_DUALLITE)
   mMemoryDeviceInfoType17.TotalWidth = 64;
   mMemoryDeviceInfoType17.DataWidth = 64;
-#elif defined(CPU_IMX6SX) || defined(SOCTYPE_SOLO)
+#elif defined(CPU_IMX6SX) || defined(SOCTYPE_SOLO) || defined(CPU_IMX6ULL)
   mMemoryDeviceInfoType17.TotalWidth = 32;
   mMemoryDeviceInfoType17.DataWidth = 32;
 #else
@@ -1561,7 +1567,7 @@ MemoryDeviceInfoUpdateSmbiosType17 (
   // 15h - Speed
 #if defined(CPU_IMX6DQ) || defined(CPU_IMX6DQP)
   mMemoryDeviceInfoType17.Speed = 533; // 533 MHz DDR3
-#elif defined(CPU_IMX6SDL) || defined(CPU_IMX6SX)
+#elif defined(CPU_IMX6SDL) || defined(CPU_IMX6SX) || defined(CPU_IMX6ULL)
   mMemoryDeviceInfoType17.Speed = 400; // 400 MHz DDR3
 #else
   #error iMX6 CPU Type not defined
diff --git a/Silicon/NXP/iMX6Pkg/Drivers/TimerDxe/Timer.c b/Silicon/NXP/iMX6Pkg/Drivers/TimerDxe/Timer.c
index 6b4db61..ac20881 100644
--- a/Silicon/NXP/iMX6Pkg/Drivers/TimerDxe/Timer.c
+++ b/Silicon/NXP/iMX6Pkg/Drivers/TimerDxe/Timer.c
@@ -46,7 +46,7 @@ TimerDriverRegisterHandler (
   IN EFI_TIMER_NOTIFY         NotifyFunction
   )
 {
-  DEBUG ((DEBUG_VERBOSE, "++TimerDriverRegisterHandler()\n"));
+  DEBUG ((DEBUG_VERBOSE, "++TimerDriverRegisterHandler(%x)\n", NotifyFunction));
   if ((NotifyFunction == NULL) && (mTimerNotifyFunction == NULL)) {
     return EFI_INVALID_PARAMETER;
   }
@@ -108,7 +108,7 @@ TimerDriverSetTimerPeriod (
             (EPIT_CR_IOVW_OVR << EPIT_CR_IOVW_LSH) |
             (EPIT_CR_DBGEN_ACTIVE << EPIT_CR_DBGEN_LSH) |
             (EPIT_CR_WAITEN_ENABLE << EPIT_CR_WAITEN_LSH) |
-            (EPIT_CR_DOZEN_ENABLE << EPIT_CR_DOZEN_LSH) |
+            //(EPIT_CR_DOZEN_ENABLE << EPIT_CR_DOZEN_LSH) |
             (EPIT_CR_STOPEN_ENABLE << EPIT_CR_STOPEN_LSH) |
             (EPIT_CR_OM_DICONNECT << EPIT_CR_OM_LSH) |
             (EPIT_CR_CLKSRC_IPGCLK << EPIT_CR_CLKSRC_LSH));
@@ -127,10 +127,14 @@ TimerDriverSetTimerPeriod (
 
   // Turn the timer on
   Value = MmioRead32 ((UINTN)&pEpit->CR);
+  
+  DEBUG ((DEBUG_VERBOSE, "TimerDriverSetTimerPeriod value %x \n", Value));
   Value &= ~(((1 << EPIT_CR_EN_WID) - 1) << EPIT_CR_EN_LSH);
   Value |= EPIT_CR_EN_ENABLE << EPIT_CR_EN_LSH;
   MmioWrite32 ((UINTN)&pEpit->CR, Value);
 
+  DEBUG ((DEBUG_VERBOSE, "TimerDriverSetTimerPeriod CR set %x CR read %x\n", Value, MmioRead32 ((UINTN)&pEpit->CR)));
+
   DEBUG ((DEBUG_VERBOSE, "--TimerDriverSetTimerPeriod(%d)=%Xh\n", TimerPeriod,
           Status));
   return Status;
@@ -159,6 +163,9 @@ TimerInterruptHandler (
   EFI_TPL OriginalTPL;
   PCSP_EPIT_REG pEpit;
 
+  
+  DEBUG ((DEBUG_INFO, "+TimerInterruptHandler"));
+
   pEpit = (PCSP_EPIT_REG) CSP_BASE_REG_PA_EPIT1;
 
   // DXE core uses this callback for the EFI timer tick. The DXE core uses locks
@@ -173,13 +180,14 @@ TimerInterruptHandler (
 
     // Signal EOI to avoid losing subsequent ticks from long duration handlers
     gInterrupt->EndOfInterrupt (gInterrupt, Source);
-
+    DEBUG ((DEBUG_INFO, "TimerInterruptHandler %x", mTimerNotifyFunction));
     if (mTimerNotifyFunction) {
       mTimerNotifyFunction (mCurrentTimerPeriod);
     }
   }
 
   gBS->RestoreTPL (OriginalTPL);
+  DEBUG ((DEBUG_INFO, "-TimerInterruptHandler"));
 }
 
 EFI_STATUS
@@ -211,7 +219,10 @@ ExitBootServicesEvent (
 
   // Disable the timer
   Status = TimerDriverSetTimerPeriod (&gTimer, 0);
+  DEBUG ((DEBUG_INFO, "ExitBootServicesEvent status %x", Status));
   ASSERT_EFI_ERROR (Status);
+  
+  DEBUG ((DEBUG_INFO, "Disabled EPIT timer on ExitBootServicesEvent"));
 }
 
 EFI_STATUS
diff --git a/Silicon/NXP/iMX6Pkg/Include/common_gpt.h b/Silicon/NXP/iMX6Pkg/Include/common_gpt.h
index 7fdfc25..dea2495 100644
--- a/Silicon/NXP/iMX6Pkg/Include/common_gpt.h
+++ b/Silicon/NXP/iMX6Pkg/Include/common_gpt.h
@@ -51,7 +51,7 @@ typedef struct {
 #define GPT_CR_STOPEN_LSH      5
 #define GPT_CR_CLKSRC_LSH      6
 #define GPT_CR_FRR_LSH         9
-#if defined(CPU_IMX6SX) || defined(CPU_IMX6SDL)
+#if defined(CPU_IMX6SX) || defined(CPU_IMX6SDL) || defined(CPU_IMX6ULL)
 #define GPT_CR_EN_24M_LSH      10
 #endif
 #define GPT_CR_SWR_LSH         15
@@ -176,6 +176,13 @@ typedef struct {
 #define GPT_CR_CLKSRC_EXTCLK            3 // External Clock (CLKIN)
 #define GPT_CR_CLKSRC_LOWFREQ           4 // Low Frequency Reference Clock
 #define GPT_CR_CLKSRC_CLK24M            5 // Crystal oscillator as Reference Clock
+#elif defined(CPU_IMX6ULL)
+#define GPT_CR_CLKSRC_NOCLK             0 // No clock to GPT
+#define GPT_CR_CLKSRC_IPGCLK            1 // ipg_clk is the clock source
+#define GPT_CR_CLKSRC_HIGHFREQ          2 // ipg_clk_highfreq
+#define GPT_CR_CLKSRC_EXTCLK            3 // ipp_gpt_clkin (external clock
+#define GPT_CR_CLKSRC_CLK32K            4 // ipg_clk_32k is clock source
+#define GPT_CR_CLKSRC_CLK24M            5 // crystal oscillator (24 Mhz) is clock source
 #else
 #error CPU Preprocessor Flag Not Defined
 #endif
@@ -184,7 +191,7 @@ typedef struct {
                                           //   continues after compare)
 #define GPT_CR_FRR_RESTART              0 // Restart mode (counter set
                                           //   to zero after compare)
-#if defined(CPU_IMX6SX) || defined(CPU_IMX6SDL)
+#if defined(CPU_IMX6SX) || defined(CPU_IMX6SDL) || defined(CPU_IMX6ULL)
 #define GPT_CR_EN_24M_DISABLE           0  // 24M clock disabled
 #define GPT_CR_EN_24M_ENABLE            1  // 24M clock enabled
 #endif
diff --git a/Silicon/NXP/iMX6Pkg/Include/iMX6.h b/Silicon/NXP/iMX6Pkg/Include/iMX6.h
index ded03ec..87fbeec 100644
--- a/Silicon/NXP/iMX6Pkg/Include/iMX6.h
+++ b/Silicon/NXP/iMX6Pkg/Include/iMX6.h
@@ -29,6 +29,8 @@
 #include "iMX6_SDL.h"
 #elif defined(CPU_IMX6SX)
 #include "iMX6_SX.h"
+#elif defined(CPU_IMX6ULL)
+#include "iMX6_ULL.h"
 #else
 #error iMX6 CPU Type Not Defined! (Preprocessor Flag)
 #endif
diff --git a/Silicon/NXP/iMX6Pkg/Include/iMX6ClkPwr.h b/Silicon/NXP/iMX6Pkg/Include/iMX6ClkPwr.h
index 1826275..2c64fc3 100644
--- a/Silicon/NXP/iMX6Pkg/Include/iMX6ClkPwr.h
+++ b/Silicon/NXP/iMX6Pkg/Include/iMX6ClkPwr.h
@@ -27,6 +27,8 @@
 #include "iMX6ClkPwr_SDL.h"
 #elif defined(CPU_IMX6SX)
 #include "iMX6ClkPwr_SX.h"
+#elif defined(CPU_IMX6ULL)
+#include "iMX6ClkPwr_ULL.h"
 #else
 #error iMX6 CPU Type Not Defined!
 #endif
diff --git a/Silicon/NXP/iMX6Pkg/Include/iMX6IoMux.h b/Silicon/NXP/iMX6Pkg/Include/iMX6IoMux.h
index f5cc186..6b939d5 100644
--- a/Silicon/NXP/iMX6Pkg/Include/iMX6IoMux.h
+++ b/Silicon/NXP/iMX6Pkg/Include/iMX6IoMux.h
@@ -31,6 +31,8 @@
 #include "iMX6IoMux_SX.h"
 #elif defined(CPU_IMX6SDL)
 #include "iMX6IoMux_SDL.h"
+#elif defined(CPU_IMX6ULL)
+#include "iMX6IoMux_ULL.h"
 #else
 #error CPU Preprocessor Flag Not Defined
 #endif
diff --git a/Silicon/NXP/iMX6Pkg/Library/TimerLib/TimerLib.c b/Silicon/NXP/iMX6Pkg/Library/TimerLib/TimerLib.c
index fa55cee..15311db 100644
--- a/Silicon/NXP/iMX6Pkg/Library/TimerLib/TimerLib.c
+++ b/Silicon/NXP/iMX6Pkg/Library/TimerLib/TimerLib.c
@@ -54,7 +54,7 @@ TimerConstructor (
   MmioWrite32 ((UINTN)&pGpt->CR,
             (GPT_CR_EN_ENABLE << GPT_CR_EN_LSH) |
             (GPT_CR_CLKSRC_CLK24M << GPT_CR_CLKSRC_LSH));
-#elif defined(CPU_IMX6SDL) || defined(CPU_IMX6SX)
+#elif defined(CPU_IMX6SDL) || defined(CPU_IMX6SX) || defined(CPU_IMX6ULL)
   // Set GPT configuration:
   // - GPT Enabled
   // - Enable 24 Mhz Oscillator
diff --git a/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6BoardMem.c b/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6BoardMem.c
index a2b601e..4de85f4 100644
--- a/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6BoardMem.c
+++ b/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6BoardMem.c
@@ -55,7 +55,21 @@ ArmPlatformGetVirtualMemoryMap (
 
   CacheAttributes = DDR_ATTRIBUTES_CACHED;
   DEBUG ((DEBUG_VERBOSE, "CacheAttributes=0x%d\n", CacheAttributes));
+#if defined(CPU_IMX6ULL)
+  VirtualMemoryTable[Index].PhysicalBase   = SOC_REGISTERS_PHYSICAL_BASE1;
+  VirtualMemoryTable[Index].VirtualBase    = SOC_REGISTERS_PHYSICAL_BASE1;
+  VirtualMemoryTable[Index].Length         = SOC_REGISTERS_PHYSICAL_LENGTH1;
+  VirtualMemoryTable[Index].Attributes     = SOC_REGISTERS_ATTRIBUTES;
 
+  VirtualMemoryTable[++Index].PhysicalBase = APBH_DMA_REGISTERS_PHYSICAL_BASE;
+  VirtualMemoryTable[Index].VirtualBase	 = APBH_DMA_REGISTERS_PHYSICAL_BASE;
+  VirtualMemoryTable[Index].Length		 = APBH_DMA_REGISTERS_PHYSICAL_LENGTH;
+  VirtualMemoryTable[Index].Attributes	 = SOC_REGISTERS_ATTRIBUTES;
+  VirtualMemoryTable[++Index].PhysicalBase = GIC_REGISTERS_PHYSICAL_BASE;
+  VirtualMemoryTable[Index].VirtualBase	 = GIC_REGISTERS_PHYSICAL_BASE;
+  VirtualMemoryTable[Index].Length		 = GIC_REGISTERS_PHYSICAL_LENGTH;
+  VirtualMemoryTable[Index].Attributes	 = SOC_REGISTERS_ATTRIBUTES;
+#else
   // SOC registers region 1 (0x00100000 size 0x00C00000)
   VirtualMemoryTable[Index].PhysicalBase   = SOC_REGISTERS_PHYSICAL_BASE1;
   VirtualMemoryTable[Index].VirtualBase    = SOC_REGISTERS_PHYSICAL_BASE1;
@@ -73,6 +87,7 @@ ArmPlatformGetVirtualMemoryMap (
   VirtualMemoryTable[Index].VirtualBase    = SOC_REGISTERS_PHYSICAL_BASE2;
   VirtualMemoryTable[Index].Length         = SOC_REGISTERS_PHYSICAL_LENGTH2;
   VirtualMemoryTable[Index].Attributes     = SOC_REGISTERS_ATTRIBUTES;
+#endif
 
   // Framebuffer
   VirtualMemoryTable[++Index].PhysicalBase = FixedPcdGet32 (PcdFrameBufferBase);
diff --git a/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6Common.c b/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6Common.c
index 3f45527..e53c600 100644
--- a/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6Common.c
+++ b/Silicon/NXP/iMX6Pkg/Library/iMX6BoardLib/iMX6Common.c
@@ -70,6 +70,10 @@ ArmPlatformInitialize (
   PcieInit ();
   SetupAudio ();
 
+  SerialPortWrite (
+    (UINT8 *)SERIAL_DEBUG_PORT_INIT_MSG,
+    (UINTN)sizeof (SERIAL_DEBUG_PORT_INIT_MSG));
+
   return RETURN_SUCCESS;
 }
 
diff --git a/Silicon/NXP/iMX6Pkg/Library/iMX6ClkPwrLib/iMX6ClkPwr.c b/Silicon/NXP/iMX6Pkg/Library/iMX6ClkPwrLib/iMX6ClkPwr.c
index 07958b1..bcf1129 100644
--- a/Silicon/NXP/iMX6Pkg/Library/iMX6ClkPwrLib/iMX6ClkPwr.c
+++ b/Silicon/NXP/iMX6Pkg/Library/iMX6ClkPwrLib/iMX6ClkPwr.c
@@ -129,7 +129,7 @@ STATIC IMX_CLOCK_CONTEXT ExpectedClocks[] = {
   {IMX_AXI_CLK_ROOT, {264000000, IMX_PERIPH_CLK}},
   {IMX_MMDC_CH0_CLK_ROOT, {528000000, IMX_PERIPH_CLK}},
 };
-#elif defined(CPU_IMX6SDL)
+#elif defined(CPU_IMX6SDL) || defined(CPU_IMX6ULL)
 STATIC IMX_CLOCK_CONTEXT ExpectedClocks[] = {
   {IMX_OSC_CLK, {24000000, IMX_CLK_NONE}},
   {IMX_PLL1_MAIN_CLK, {792000000, IMX_OSC_CLK}},
@@ -1072,6 +1072,7 @@ ImxpGetClockInfo (
   return EFI_SUCCESS;
 }
 
+#if !defined(CPU_IMX6ULL)
 /**
   Power on and clock the GPU2D/GPU3D blocks.
 
@@ -1115,6 +1116,7 @@ ImxClkPwrGpuEnable (
   return EFI_SUCCESS;
 }
 
+
 EFI_STATUS
 ImxClkPwrIpuDIxEnable (
   VOID
@@ -1134,6 +1136,7 @@ ImxClkPwrIpuDIxEnable (
   ImxSetPll5ReferenceRate (65000000);
   return EFI_SUCCESS;
 }
+#endif
 
 #if defined(CPU_IMX6DQ) || defined(CPU_IMX6DQP)
 /**
@@ -1216,17 +1219,21 @@ ImxSetPll5ReferenceRate (
 
   pCcmRegisters = (IMX_CCM_REGISTERS *) IMX_CCM_BASE;
   ChscddrReg.AsUint32 = MmioRead32 ((UINTN)&pCcmRegisters->CHSCCDR);
+#if !defined(CPU_IMX6ULL)
   ImxClkPwrSetClockGate (IMX_IPU1_DI0_CLK_ENABLE, IMX_CCM_CCGR_OFF);
   ImxClkPwrSetClockGate (IMX_IPU1_DI1_CLK_ENABLE, IMX_CCM_CCGR_OFF);
 #if defined(CPU_IMX6DQ) || defined(CPU_IMX6DQP)
   ImxClkPwrSetClockGate (IMX_IPU2_DI0_CLK_ENABLE, IMX_CCM_CCGR_OFF);
   ImxClkPwrSetClockGate (IMX_IPU2_DI1_CLK_ENABLE, IMX_CCM_CCGR_OFF);
 #endif
+#endif
   ChscddrReg.ipu1_di0_podf = DxPodfDivider - 1;
   ChscddrReg.ipu1_di1_podf = DxPodfDivider - 1;
   MmioWrite32 ((UINTN)&pCcmRegisters->CHSCCDR, ChscddrReg.AsUint32);
 
-  ImxClkPwrSetClockGate (IMX_IPU1_DI0_CLK_ENABLE, IMX_CCM_CCGR_ON);
+#if !defined(CPU_IMX6ULL)
+ImxClkPwrSetClockGate (IMX_IPU1_DI0_CLK_ENABLE, IMX_CCM_CCGR_ON);
+#endif
   ImxSetClockRatePLL5 (TargetFreq, postDivSelect[PostDivSelectCount]);
   return EFI_SUCCESS;
 }
diff --git a/Silicon/NXP/iMX6Pkg/Library/iMX6UsbPhyLib/iMX6UsbPhy.c b/Silicon/NXP/iMX6Pkg/Library/iMX6UsbPhyLib/iMX6UsbPhy.c
index 317d17d..3e7b992 100644
--- a/Silicon/NXP/iMX6Pkg/Library/iMX6UsbPhyLib/iMX6UsbPhy.c
+++ b/Silicon/NXP/iMX6Pkg/Library/iMX6UsbPhyLib/iMX6UsbPhy.c
@@ -201,6 +201,21 @@ ImxUsbEhciResetController (
     ASSERT (UsbModeReg.CM == IMX_USBMODE_HOST);
   }
 
+#ifdef CPU_IMX6ULL
+	if (ImxUsbPhyId == IMX_USBPHY1) {
+        volatile USB_USBMODE_REG* UsbModeRegPtr;
+        USB_USBMODE_REG UsbModeReg;
+        DEBUG((DEBUG_INFO, "Switching USB OTG Port to Host\n"));
+        UsbModeRegPtr = (USB_USBMODE_REG*)(IMX_USBCORE_BASE + IMX_USBCORE_LENGTH + IMX_USBMODE_OFFSET);
+        UsbModeReg.AsUint32 = MmioRead32((UINTN)UsbModeRegPtr);
+        UsbModeReg.CM = IMX_USBMODE_HOST;
+        MmioWrite32((UINTN)UsbModeRegPtr, UsbModeReg.AsUint32);
+        DEBUG_CODE_BEGIN();
+        UsbModeReg.AsUint32 = MmioRead32((UINTN)UsbModeRegPtr);
+        ASSERT(UsbModeReg.CM == IMX_USBMODE_HOST);
+        DEBUG_CODE_END();
+    }
+#endif
   return EFI_SUCCESS;
 }
 
@@ -247,7 +262,9 @@ ImxUsbPhyInit (
   // Set power polarity
   UsbNcHcCtrlReg.AsUint32 = MmioRead32 ((UINTN)UsbNcUhCtrlRegPtr);
   UsbNcHcCtrlReg.PWR_POL = 1;
+  #if !(defined(CPU_IMX6ULL))
   UsbNcHcCtrlReg.AsUint32 |= 0x2;     // Reserved bit
+  #endif
   MmioWrite32 ((UINTN)UsbNcUhCtrlRegPtr, UsbNcHcCtrlReg.AsUint32);
 
   // Disable external USB charger detector
@@ -310,7 +327,7 @@ ImxUsbPhyInit (
   // Apply PHY configuration:
   // - Enable low/full speed devices.
   UsbPhyCtrlReg.AsUint32 = 0;
-#if defined(CPU_IMX6DQ)
+#if defined(CPU_IMX6DQ) || defined(CPU_IMX6ULL)
   UsbPhyCtrlReg.ENAUTOSET_USBCLKS = 1;
   UsbPhyCtrlReg.ENAUTOCLR_USBCLKGATE = 1;
   UsbPhyCtrlReg.ENAUTO_PWRON_PLL = 1;
@@ -320,7 +337,7 @@ ImxUsbPhyInit (
   UsbPhyCtrlReg.ENUTMILEVEL2 = 1;
   UsbPhyCtrlReg.ENUTMILEVEL3 = 1;
   MmioWrite32 ((UINTN)&UsbPhyRegsPtr->USBPHY_CTRL_SET, UsbPhyCtrlReg.AsUint32);
-#if defined(CPU_IMX6DQ)
+#if defined(CPU_IMX6DQ) || defined(CPU_IMX6ULL)
   MmioWrite32 ((UINTN)&UsbPhyRegsPtr->USBPHY_IP_SET, IMX_USBPHY_IP_FIX);
 #endif
 
diff --git a/Silicon/NXP/iMX6Pkg/iMX6CommonDsc.inc b/Silicon/NXP/iMX6Pkg/iMX6CommonDsc.inc
index 1892693..81a9cd0 100644
--- a/Silicon/NXP/iMX6Pkg/iMX6CommonDsc.inc
+++ b/Silicon/NXP/iMX6Pkg/iMX6CommonDsc.inc
@@ -235,7 +235,7 @@
   SecurityManagementLib|MdeModulePkg/Library/DxeSecurityManagementLib/DxeSecurityManagementLib.inf
   ArmSoftFloatLib|ArmPkg/Library/ArmSoftFloatLib/ArmSoftFloatLib.inf
 
-!if $(CONFIG_OPTEE) == TRUE
+#!if $(CONFIG_OPTEE) == TRUE
   IntrinsicLib|CryptoPkg/Library/IntrinsicLib/IntrinsicLib.inf
   OpensslLib|CryptoPkg/Library/OpensslLib/OpensslLib.inf
   BaseCryptLib|CryptoPkg/Library/BaseCryptLib/BaseCryptLib.inf
@@ -243,7 +243,7 @@
   HashLib|SecurityPkg/Library/HashLibBaseCryptoRouter/HashLibBaseCryptoRouterDxe.inf
   Tpm2DeviceLibOptee|Platform/Microsoft/OpteeClientPkg/Library/Tpm2DeviceLibOptee/Tpm2DeviceLibOptee.inf
   Tpm2CommandLib|SecurityPkg/Library/Tpm2CommandLib/Tpm2CommandLib.inf
-!endif
+#!endif
 
 [LibraryClasses.common.UEFI_APPLICATION]
   PcdLib|MdePkg/Library/DxePcdLib/DxePcdLib.inf
@@ -310,6 +310,11 @@
   #
   # ARM General Interrupt Controller settings
   #
+!if $(IMX_FAMILY) == IMX6ULL
+  gArmTokenSpaceGuid.PcdGicDistributorBase|0x00A01000
+  gArmTokenSpaceGuid.PcdGicInterruptInterfaceBase|0x00A02000
+  gArmTokenSpaceGuid.PcdArmPrimaryCore|0x000
+!else
   gArmTokenSpaceGuid.PcdGicDistributorBase|0x00A01000
   gArmTokenSpaceGuid.PcdGicInterruptInterfaceBase|0x00A00100
   gArmTokenSpaceGuid.PcdArmPrimaryCore|0x000
@@ -318,6 +323,7 @@
   # ARM L2x0 PCDs
   #
   #gArmTokenSpaceGuid.PcdL2x0ControllerBase|0x00A02000
+!endif
 
   #
   # GPT Timer Frequency
@@ -333,8 +339,21 @@
 [PcdsFixedAtBuild.common]
   # Size of the region used by UEFI in permanent memory (Reserved 16MB)
   gArmPlatformTokenSpaceGuid.PcdSystemMemoryUefiRegionSize|0x01000000
-
-!if $(IMX_FAMILY) == IMX6SX
+!if $(IMX_FAMILY) == IMX6ULL
+  #
+  # Refer to the detailed memory map at OpteeClientPkg PCDs section below
+  #
+  giMX6TokenSpaceGuid.PcdMemoryStartAddress|0x80000000
+  gArmTokenSpaceGuid.PcdSystemMemoryBase|0x82A00000
+  !if $(DRAM_SIZE) == DRAM_512MB
+  #
+  # Board DDR starts at 0x80000000 and ends 0x9FFF0000 (512MB)
+  # SystemMemorySize is 0x9DFF0000 - PcdSystemMemoryBase
+  #
+  giMX6TokenSpaceGuid.PcdMemoryEndAddress|0x9FFF0000
+  gArmTokenSpaceGuid.PcdSystemMemorySize|0x1B5F0000
+  !endif
+!elseif $(IMX_FAMILY) == IMX6SX
   #
   # Refer to the detailed memory map at OpteeClientPkg PCDs section below
   #
@@ -474,7 +493,7 @@
   #
   # In debug builds enable error, cache, info, load, warn, and init
   #
-  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel| 0x80000047
+  gEfiMdePkgTokenSpaceGuid.PcdDebugPrintErrorLevel| 0x80400047
 !endif
   gEfiMdePkgTokenSpaceGuid.PcdReportStatusCodePropertyMask|0x07
   gEfiMdePkgTokenSpaceGuid.PcdPlatformBootTimeOut|3
@@ -556,7 +575,80 @@
 #
 ########################
 [PcdsFixedAtBuild.common]
-!if $(IMX_FAMILY) == IMX6SX
+!if $(IMX_FAMILY) == IMX6ULL
+  #
+  # Reserved for TPM2 ACPI
+  # 0x80814000 - 0x80816FFF
+  #
+  gOpteeClientPkgTokenSpaceGuid.PcdTpm2AcpiBufferBase|0x80814000
+  gOpteeClientPkgTokenSpaceGuid.PcdTpm2AcpiBufferSize|0x3000
+  #
+  # iMX Plaform Memory Layout
+  #
+  # +-------------------+===> (0x80000000) PcdFrameBufferBase (DDR Start Address)
+  # |Frame Buffer       |  ^
+  # |                   |  |  (0x00800000) PcdFrameBufferSize 8MB
+  # |                   |  v
+  # +-------------------+===
+  # |                   |     Gap
+  # +-------------------|===> (0x80814000) PcdTpm2AcpiBufferBase
+  # |TPM2 Control Area  |  ^
+  # |                   |  |  (0x3000) 12KB
+  # |                   |  v
+  # +-------------------+===> (0x80817000) PcdGlobalDataBaseAddress
+  # | Global Data       |  ^
+  # |                   |  |  (0x1000) PcdGlobalDataSize 4KB
+  # |                   |  v
+  # +-------------------+===
+  # | Gap               |
+  # +-------------------+===> (0x80820000) UEFI Load Address
+  # | UEFI              |  ^
+  # |                   |  |  (0x1D0000) 1920KB
+  # |                   |  v
+  # +-------------------+===> (0x80A00000) PcdTrustZonePrivateMemoryBase (OPTEE image base address)
+  # | TZ Private Memory |  ^
+  # | (OPTEE)           |  |  (0x1E00000) 30MB
+  # |                   |  v
+  # +-------------------+===> (0x82800000) PcdTrustZoneSharedMemoryBase (includes mobj bookkeeping page)
+  # | TZ Shared Memory  |  ^
+  # |                   |  |  (0x200000) 2MB
+  # |                   |  v
+  # +-------------------+===> (0x82A00000) PcdSystemMemoryBase
+  # | Operating System  |  ^
+  # | Memory            |  |  
+  # |                   |  |  (0x1B5F0000) 437MB for 512MB DRAM
+  # |                   |  |  
+  # |                   |  v  
+  # +------------------ +===> 0x8DFFFFFF/0x9DFFFFFF
+  #
+  # Reserved for Optee private memory (31M)
+  # 0x80A00000 - 0x827FFFFF
+  #
+  # TrustZone private memory (?Mb OPTEE + ?Mb PSCI)
+  # 0x8E000000 - 8FFFFFFF  (256MB)          0x9E000000 - 9FFFFFFF    (512MB)
+  # This memory is managed privately by the OpTEE OS.
+  #    CFG_DDR_TEETZ_RESERVED_START & CFG_DDR_TEETZ_RESERVED_START
+  #
+
+  DEFINE GLOBAL_DATA_BASE_ADDRESS = 0x80817000
+
+  gOpteeClientPkgTokenSpaceGuid.PcdTrustZonePrivateMemoryBase|0x80A00000
+  gOpteeClientPkgTokenSpaceGuid.PcdTrustZonePrivateMemorySize|0x01E00000
+
+  #
+  # TrustZone shared memory (2Mb)
+  # 0x12800000 - 0x129FFFFF
+  # This memory is managed by the normal world but shared with the OpTEE OS.
+  # It must match OpTEE optee_os/core/arch/arm/plat-imx/platform_config.h:
+  #    CFG_SHMEM_START & CFG_SHMEM_SIZE
+  # NOTE: The first page of the SHMEM is owned by OPTEE for mobj bookkeeping
+  # and we should not touch it. We will skip the first 4K of SHMEM and take that
+  # into account for SHMEM size in PcdTrustZoneSharedMemorySize.
+  #
+  gOpteeClientPkgTokenSpaceGuid.PcdTrustZoneSharedMemoryBase|0x82800000
+  gOpteeClientPkgTokenSpaceGuid.PcdTrustZoneSharedMemorySize|0x00200000
+  giMX6TokenSpaceGuid.PcdFrameBufferBase|0x80000000
+!elseif $(IMX_FAMILY) == IMX6SX
   #
   # Reserved for TPM2 ACPI
   # 0x82000000 - 0x82002FFF
@@ -809,11 +901,13 @@
   EmbeddedPkg/RealTimeClockRuntimeDxe/RealTimeClockRuntimeDxe.inf
   EmbeddedPkg/ResetRuntimeDxe/ResetRuntimeDxe.inf
   MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+
   MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf {
     <LibraryClasses>
       NULL|SecurityPkg/Library/DxeImageVerificationLib/DxeImageVerificationLib.inf
       NULL|SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.inf
   }
+
   Silicon/NXP/iMX6Pkg/Drivers/TimerDxe/TimerDxe.inf
   MdeModulePkg/Universal/CapsuleRuntimeDxe/CapsuleRuntimeDxe.inf
   MdeModulePkg/Universal/WatchdogTimerDxe/WatchdogTimer.inf
@@ -850,24 +944,29 @@
   MdeModulePkg/Bus/Usb/UsbMouseAbsolutePointerDxe/UsbMouseAbsolutePointerDxe.inf
 !endif
 
+!if $(CONFIG_PCIE) == TRUE
   # PCIe support
   Silicon/NXP/iMX6Pkg/Drivers/PciExpress/iMX6PciExpress.inf
+!endif
 
   #
   # Generic Bds (Not Intel's)
   #
   MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
   MdeModulePkg/Universal/DevicePathDxe/DevicePathDxe.inf
+#!if $(CONFIG_HEADLESS) != TRUE
   MdeModulePkg/Universal/DisplayEngineDxe/DisplayEngineDxe.inf
+#!endif
   MdeModulePkg/Universal/HiiDatabaseDxe/HiiDatabaseDxe.inf
   MdeModulePkg/Universal/SetupBrowserDxe/SetupBrowserDxe.inf
+#!if $(CONFIG_HEADLESS) != TRUE
   MdeModulePkg/Application/UiApp/UiApp.inf {
     <LibraryClasses>
       NULL|MdeModulePkg/Library/DeviceManagerUiLib/DeviceManagerUiLib.inf
       NULL|MdeModulePkg/Library/BootManagerUiLib/BootManagerUiLib.inf
       NULL|MdeModulePkg/Library/BootMaintenanceManagerUiLib/BootMaintenanceManagerUiLib.inf
   }
-
+#!endif
   #
   # Shell
   #
@@ -921,9 +1020,10 @@ MdeModulePkg/Universal/Variable/EmuRuntimeDxe/EmuVariableRuntimeDxe.inf
   Platform/Microsoft/Application/AuthVarTest/AuthVarTest.inf
 !endif
 
+!if $(CONFIG_OPTEE) == TRUE
   Platform/Microsoft/OpteeClientPkg/Application/OpteeClientApiTest/OpteeClientApiTest.inf
   #SecurityPkg/Application/VariableAuthTestDxe/VariableAuthTestDxe.inf
-
+!endif
 #
 # Boilerplate for compiling UEFI applications and UEFI drivers with the
 # standard library.
diff --git a/Silicon/NXP/iMX6Pkg/iMX6CommonFdf.inc b/Silicon/NXP/iMX6Pkg/iMX6CommonFdf.inc
index a55acfb..00f196f 100644
--- a/Silicon/NXP/iMX6Pkg/iMX6CommonFdf.inc
+++ b/Silicon/NXP/iMX6Pkg/iMX6CommonFdf.inc
@@ -22,7 +22,9 @@
   INF ArmPkg/Drivers/CpuDxe/CpuDxe.inf
 
   INF MdeModulePkg/Core/RuntimeDxe/RuntimeDxe.inf
+#!if $(CONFIG_OPTEE) == TRUE
   INF MdeModulePkg/Universal/SecurityStubDxe/SecurityStubDxe.inf
+#!endif
   INF MdeModulePkg/Universal/WatchdogTimerDxe/WatchdogTimer.inf
   INF MdeModulePkg/Universal/CapsuleRuntimeDxe/CapsuleRuntimeDxe.inf
   INF MdeModulePkg/Universal/MonotonicCounterRuntimeDxe/MonotonicCounterRuntimeDxe.inf
@@ -62,10 +64,12 @@
   INF MdeModulePkg/Bus/Usb/UsbMassStorageDxe/UsbMassStorageDxe.inf
 !endif
 
+!if $(CONFIG_PCIE) == TRUE
   #
   # PCIe
   #
   INF Silicon/NXP/iMX6Pkg/Drivers/PciExpress/iMX6PciExpress.inf
+!endif
 
   #
   # Bds
@@ -73,9 +77,11 @@
   INF MdeModulePkg/Universal/DevicePathDxe/DevicePathDxe.inf
   INF MdeModulePkg/Universal/HiiDatabaseDxe/HiiDatabaseDxe.inf
   INF MdeModulePkg/Universal/SetupBrowserDxe/SetupBrowserDxe.inf
+#!if $(CONFIG_HEADLESS) != TRUE
   INF MdeModulePkg/Universal/DisplayEngineDxe/DisplayEngineDxe.inf
-  INF MdeModulePkg/Universal/BdsDxe/BdsDxe.inf
   INF MdeModulePkg/Application/UiApp/UiApp.inf
+#!endif
+  INF MdeModulePkg/Universal/BdsDxe/BdsDxe.inf 
 
   #
   # UEFI application (Shell Embedded Boot Loader)
diff --git a/Silicon/NXP/iMXPlatformPkg/Drivers/SdhcDxe/SdhcDxe.h b/Silicon/NXP/iMXPlatformPkg/Drivers/SdhcDxe/SdhcDxe.h
index e3f7fe6..f06abe6 100644
--- a/Silicon/NXP/iMXPlatformPkg/Drivers/SdhcDxe/SdhcDxe.h
+++ b/Silicon/NXP/iMXPlatformPkg/Drivers/SdhcDxe/SdhcDxe.h
@@ -49,11 +49,9 @@ typedef struct {
 #define LOG_FMT_HELPER(FMT, ...) \
     "SDHC%d:" FMT "%a\n", ((SdhcCtx != NULL) ? SdhcCtx->SdhcId : -1), __VA_ARGS__
 
-#define LOG_INFO(...) \
-    DEBUG((DEBUG_INFO | DEBUG_BLKIO, LOG_FMT_HELPER(__VA_ARGS__, "")))
+#define LOG_INFO(...) 
 
-#define LOG_TRACE(...) \
-    DEBUG((DEBUG_VERBOSE | DEBUG_BLKIO, LOG_FMT_HELPER(__VA_ARGS__, "")))
+#define LOG_TRACE(...) 
 
 #define LOG_ERROR(...) \
     DEBUG((DEBUG_ERROR | DEBUG_BLKIO, LOG_FMT_HELPER(__VA_ARGS__, "")))
EDK2-Platforms diff end
